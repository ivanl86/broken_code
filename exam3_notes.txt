
is-a relationship is inheritance
base class : derived class
derived class is inherit from the base class
derived class is a specailize version of the base class

class vs struct
All data in class are private by defeault
All data in struct are public by defeault

private vs protected vs private
They are access modifiers

private: all data in private are not accessible outside of the class
protected: subclass functions can access protected class member functions but not accessible outside of the class
public: all data in public are accessible outside of the class

constructor: no return type, must have the same name as the class name, and must be in public
destructor: delete the object once it is out of scope

virtual function must have same return type and name
virtual void print();
it has its own definition, but can be overridden by subclass function
virtual void print() = 0;
called pure virtual function, it does not has definition and must be overridden by subclass function

smart pointer
#include <memory>
std::unique_ptr<data_type> ptr = std::make_unique<data_type>(initialization)
when the pointer is pointing to a resource, no other pointer can point to the same resource
When the pointer is out of scope, the resource is destroyed

std::shared_ptr<data_type> ptr = std::make_shared<data_type>(initialization)
Can have multiple pointers pointing to the same resource
The resource is destroyed only when all the pointers are out of scope

explicit function
only direct initialization no copy initialization

polymorphism
definition: the same entity(function or object) behaves differently in different scenarios
compile time polymorphism: it is function overloading and operator overloading
run time polymorphism: it is function overriding

new keyword
allocate memory and initialize an object or array of objects of specific type and return a non-zero pointer to the object(s)

delete operator
deallocate a block of memory allocated by the new keyword

dynamic stack
allocate memory
int val;
int * ptr = new int;
int array[val];
int * arrPtr = new int[val];

deallocate memory
delete ptr;
delete[] arrPtr;

operator overloading
same operator with different definitions, and it use definition depends on the arguments

void operator+(const Pet&);

void Pet::operator=(const Pet &p)
{
    type = p.type;
    breed = p.bread;
    name = p.name;
}

friend
a friend function of the class has access to both private and protected data member of the class

class Pet
{
    friend std::ostream& operator<<(std::ostream&, const Pet&);

public:
...}

std::ostream& operator<<(std::ostream& os, const Pet& p)
{
    os << p.getName() << " the " << p.getType() << " is a " << p.getBreed() << " and says " << p.speak();
    return os;
}

static variable in a class
when declare a variblae of a class as static,
only one copy of the static variable is created no matter how many objects of the class has created

the static variable is shared by all objects of the class
when the first object is created, all static varibales are initialize to zero unless specified
if one of the objects changed the static varialbe, it reflects that change across all objects

static member function is independent of any particular object of the class
the static member function can be called if no object of the class exist
and the static member function can only be accessed by using the class name and the scope resolution operator ::
className::staticFunctionName();

static member function can only access static data member,other static member functions and any other functions from outside the class